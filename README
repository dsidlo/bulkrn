
bulkrn.pl - ReNumber Files  Version (0.0.2)

  Safely renumbers and/or renames numeric portions of file(s) name in the
  current directory. Watches for filename overlap/overwrite conditions what
  would result in a loss of a file and undoes any changes if there is a chance
  that data-loss might occur.

  By default, the rename process only runs in "test" mode, and you must add the
  -go option to perform the actual rename commands against the file system.
  This guards against the possibility of loosing "file name" information in the
  case where the rename parameters are incorrect, and the renames are performed
  (with no overwrite conditions, and are not undone), and as a result, all
  files have been renamed as simple number strings.
  So, Always check your final results first before committing with the -go
  option.

  Again, by default (even with the -go option), a simulated test is always
  run to ensure that no data-loss occurs before the actual file renames are
  performed. This default pre-test can be disabled by the [--run-only | -x]
  option. This is especially useful when using this program within a script.

  The -r and -c options may be used alone or in tandem to either rename or
  renumber some portion of the file name, for the set of files that match the -f
  file pattern.

  usage: bulkrn.pl [-a|-h|-t|-v-|-x] -f [regexpWith2BackRefs] [-r [br:n1|n1-n2:nn[!]]]
                   [-s [SequentialIncrement]] [-d [ZeroPaddedLength]]
                   [-c [SubstitutionPattern]]
                   [-go]

  Requires that the first argument, be defined as a pattern that matches to
  a set of file-names of interest, where the pattern returns upto
  9 back-reference values. The parameter br is the Back Reference value which
  will be changed into a new number. So the return value of that back reference
  must be an integer value. Every portion of the file name that will
  become part of the new name must be held in a back reference. If it is not,
  that portion of the file name will be removed from the new file name.

  By only supplying the [--filePat | -f] option and a file pattern, you can test
  that your file pattern is picking up the files that you expect to rename. And,
  you can the how the file name splits up into its back-references.

$ ./bulkrn.pl -f '(mwlog\.wfiejb\d+)(\.\d\d\d\d)(08\d\d)' 
Testing the FilePattern...
FilePattern Test: mwlog.wfiejb1.20100810 => (mwlog.wfiejb1) (.2010) (0810)
FilePattern Test: mwlog.wfiejb1.20100811 => (mwlog.wfiejb1) (.2010) (0811)
FilePattern Test: mwlog.wfiejb1.20100812 => (mwlog.wfiejb1) (.2010) (0812)
...

 The file name pattern...

  -filePat|-f [filePattern RegExpp]

  '(mwlog\.wfiejb)(\d+)(\..*)'
    ^------------  ^--- ^--- 
    |              |    |
    |              |    +---: BackRef $3 -> $fn1
    |              +--------: BackRef $2 -> $fn2
    +-----------------------: BackRef $1 -> $fn3

  In the example above...
  For our example, we want to renumber the values of the 2nd back-reference, so
  the 2nd back-reference must allways return a numeric value.
  This numberic value is compared against n1. And, if there is a match, n1 is
  substitued with the value of nn. And the new file name is built...

  $newFn = $fn1.($fn+(n2-n1)).$fn3;

  The --reNum|-r parameter consists of... [br:n1|n1-n2:nn]

  br: Back Reference value that is the numberic value that will be changed.
  n1: The first numeric value that will be changed.
  n2: The last  numeric value that will be changed.
  nn: The numberic value that n1 will be changed to.
      Subsequent values will be changed to n2+(nn-n1) incrementing the value
      by the difference between n1 and nn.
      An exclaimation-point symbol after nn (:20!) fixes the new number to that
      single value. The "new number" value will not change relative to the 
      Back Reference value found in the file name.

  ** If n1 is specified without n2,only the files whos back-reference values
     match n1 will be change to the new number.
     If n1 is specified with a trailing dash "-" and n2 is not specified "10-",
     all values from n1 and greater are changed to the new value. 
     If n1 and n2 exist with a dash "-" between them "10-20" all values between
     and including n1 and n2 are changed to a new value.

  The regexp file pattern must contain back-references for all portions of the
  original file name that you want to preserve, including a back reference for
  the portion that contains all numerics (that will be renumbered).

  For example: bulkrn.pl -f '(mwlog\.wfiejb)(\d+)(\..*)' -r 2:5:15 
  Will change mwlog.wfiejb5.20100701 to mwlog.wfiejb5.20100701.

  But,: bulkrn.pl -f 'mwlog\.wfiejb(\d+)(\..*)' -r 1:5:15 
  Will change mwlog.wfiejb5.20100701 to 5.20100701.
  Because, the "mwlog\.wfiejb" portion of the file name is not enclosed in
  parens and will not be preserved
   
  example: bulkrn.pl -f '(mwlog\.wfiejb)(\d+)(\..*)' -r 2:5:15 

  Above, only n1 and nn are specified as options, all $2 back-reference values
  that match 5 will be incrmented by 10 (nn-n1).

  example: bulkrn.pl -f '(mwlog\.wfiejb)(\d+)(\..*)' -r 2:5-:15 

  Above, only n1 and nn are specified as options, all $2 back-reference values
  that match 5 and above will be incrmented by 10 (nn-n1).

  example: bulkrn.pl -f '(mwlog\.wfiejb)(\d+)(\..*)' -r 2:5-7:15

  Above, n1-n2 and nn are specified as options, only $2 back-reference values
  that match 5 thru 7 are incrmented by 10. 

  The rename process watches for file name overlap conditions what would cause
  a file to be overwritten and lost. If such conditions are found, the process
  aborts after undoing all file renames that had been done thus far.

  Other options:

  --change|-c [SubstitutionPattern] (-c 's/mwlog/mxx/i')
  A substitution pattern that changes some portion of the filename if found.
  The back-references $1..$9 may be used in the "matching" portion of the
  string substitution equation to refer to the back-refs in the original
  --filePat parameter. This is useful for upper and lowercasing portions of
  a filename.

  --reSeq|-s [SequentialIncrement] (-s 1)
  Resequence the numbers (n1-n2) begining with nn such that the new values are
  contiguous and optionaly incremented by [increment].

  --format|-d [LeadingZerosFormatLength]
  Format the new numberic value with leading zeros to a length of n.
  example: -d 5

  --autoDir|-a
  Automatically create directories along new file paths.
  With out this option, if new file paths do not exist, the rename operation
  will fail.

  --test|-t
  Test the renumbering/renaming process against the filenames in the current
  directory.

  --verbose | -v
  Print details of the renaming process.
  There are 3 levels of verbosity "-v", "-v -v" and "-v -v -v"

  --help|-h
  Output this help text.

  (See: "perldoc bulkrn.pl" for more details and examples of use.)
